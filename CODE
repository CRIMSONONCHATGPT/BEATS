<style>
:root { color-scheme: dark; --accent-hue: 24; }
* { box-sizing: border-box; }
html, body {
margin: 0;
padding: 0;
width: 100%;
height: 100%;
min-height: 100vh;
overflow: hidden;
background: radial-gradient(circle at 30% 30%, #0a0f1e 0%, #050910 40%, #02040a 70%);
color: #e8edf3;
font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
}
body {
position: relative;
display: grid;
grid-template-columns: minmax(320px, 460px) 1fr;
gap: 28px;
padding: 32px;
align-items: center;
}
#vizRoot {
position: relative;
z-index: 5;
padding: 18px 20px;
background: rgba(8, 12, 22, 0.72);
border: 1px solid rgba(255, 255, 255, 0.08);
border-radius: 18px;
box-shadow:
0 0 28px rgba(0, 0, 0, 0.45),
0 0 60px rgba(255, 99, 71, 0.18),
0 0 120px rgba(70, 165, 255, 0.12);
backdrop-filter: blur(18px) saturate(180%);
display: flex;
flex-direction: column;
gap: 18px;
}
#vizRoot header h1 {
margin: 0;
font-size: 26px;
letter-spacing: 0.3px;
}
#vizRoot header p {
margin: 6px 0 0;
color: #cdd7e8;
line-height: 1.45;
}
#controls {
display: flex;
gap: 12px;
align-items: center;
flex-wrap: wrap;
}
#startBtn {
display: inline-flex;
align-items: center;
justify-content: center;
gap: 8px;
min-width: 220px;
padding: 14px 20px;
font-size: 18px;
border: 0;
border-radius: 12px;
background: linear-gradient(120deg, hsl(var(--accent-hue), 90%, 65%), hsl(var(--accent-hue), 90%, 50%));
color: #fff;
cursor: pointer;
box-shadow:
0 0 18px hsla(var(--accent-hue), 95%, 60%, 0.55),
0 0 36px hsla(var(--accent-hue), 95%, 50%, 0.32);
transition: transform 160ms ease, box-shadow 160ms ease, filter 120ms ease;
animation: breathe 2.2s ease-in-out infinite;
}
#startBtn:hover { transform: translateY(-2px) scale(1.01); box-shadow: 0 10px 28px rgba(255, 64, 64, 0.55); }
#startBtn:focus-visible { outline: 2px solid rgba(255, 255, 255, 0.45); outline-offset: 2px; box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.12); }
#startBtn:disabled { opacity: 0.6; cursor: not-allowed; animation: none; }
[data-status] {
flex: 1;
min-width: 240px;
padding: 12px 14px;
font-size: 15px;
color: #dfe8f5;
background: rgba(6, 10, 20, 0.72);
border: 1px solid rgba(255, 255, 255, 0.1);
border-radius: 12px;
box-shadow: 0 0 18px rgba(0, 0, 0, 0.4);
line-height: 1.4;
transition: transform 180ms ease, box-shadow 180ms ease, color 180ms ease, background 180ms ease;
}
[data-status][data-tone="warn"] {
font-size: 16px;
font-weight: 700;
color: #ffb3c1;
background: radial-gradient(circle at 30% 30%, rgba(255, 71, 87, 0.35), rgba(80, 10, 22, 0.8));
border-color: rgba(255, 99, 71, 0.5);
box-shadow:
0 0 25px rgba(255, 71, 87, 0.35),
0 0 60px rgba(0, 0, 0, 0.6);
transform: scale(1.01);
}
.panel {
padding: 12px 14px;
border-radius: 12px;
background: rgba(12, 18, 32, 0.75);
border: 1px solid rgba(255, 255, 255, 0.06);
box-shadow: 0 6px 18px rgba(0,0,0,0.35);
}
.panel h3 { margin: 0 0 8px; font-size: 16px; color: #f0f4ff; letter-spacing: 0.2px; }
.panel ol, .panel ul { margin: 0; padding-left: 18px; color: #c9d5e8; line-height: 1.6; }
.insanity-control {
    position: fixed;
    bottom: 24px;
    right: 24px;
    z-index: 8;
    display: flex;
    flex-direction: column;
    gap: 12px;
    min-width: 280px;
    max-width: 360px;
    padding: 14px 16px;
    background: linear-gradient(135deg, rgba(10, 14, 26, 0.9), rgba(22, 30, 48, 0.92));
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 14px;
    box-shadow: 0 16px 36px rgba(0,0,0,0.3);
    color: #e8edf3;
    backdrop-filter: blur(12px) saturate(160%);
}
.insanity-control .title { font-weight: 800; letter-spacing: 0.2px; color: #fff; }
.insanity-control .sub { color: #9fb3d8; font-size: 12px; letter-spacing: 0.2px; }
.insanity-control .value { font-weight: 700; min-width: 64px; text-align: right; color: #fff; }
.insanity-control .pill {
    padding: 2px 8px;
    border-radius: 999px;
    background: rgba(255, 255, 255, 0.1);
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.6px;
    color: #c3d4f5;
}
.insanity-control .value.with-auto { display: flex; align-items: center; gap: 6px; }
.insanity-control .value small { color: #9fb3d8; font-weight: 600; }
.insanity-control .slider-row {
    display: flex;
    align-items: center;
    gap: 12px;
}
.insanity-control input[type="range"] {
    flex: 1;
    -webkit-appearance: none;
    appearance: none;
    height: 10px;
    border-radius: 999px;
    background: linear-gradient(90deg, hsla(var(--accent-hue), 90%, 60%, 0.9), rgba(255,255,255,0.14));
    outline: none;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08);
}
.insanity-control input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: linear-gradient(135deg, hsl(var(--accent-hue), 90%, 70%), hsl(var(--accent-hue), 90%, 55%));
    box-shadow: 0 4px 14px rgba(0,0,0,0.35);
    border: 1px solid rgba(255,255,255,0.4);
    cursor: pointer;
}
.insanity-control input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: linear-gradient(135deg, hsl(var(--accent-hue), 90%, 70%), hsl(var(--accent-hue), 90%, 55%));
    box-shadow: 0 4px 14px rgba(0,0,0,0.35);
    border: 1px solid rgba(255,255,255,0.4);
    cursor: pointer;
}
.insanity-control.hidden { display: none; }
.insanity-control.popped {
    animation: popIn 360ms cubic-bezier(0.18, 0.82, 0.3, 1.2);
}
#helpers { display: grid; gap: 12px; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
@keyframes popIn {
0% { opacity: 0; transform: translateY(8px) scale(0.94); }
70% { opacity: 1; transform: translateY(-2px) scale(1.04); }
100% { opacity: 1; transform: translateY(0) scale(1); }
}
#toast {
position: fixed;
top: 18px;
right: 18px;
padding: 12px 16px;
border-radius: 10px;
background: rgba(8, 12, 22, 0.85);
color: #f5f7fb;
border: 1px solid rgba(255, 255, 255, 0.12);
box-shadow: 0 10px 28px rgba(0, 0, 0, 0.35);
opacity: 0;
transform: translateY(-10px);
transition: opacity 220ms ease, transform 220ms ease;
pointer-events: none;
z-index: 6;
font-size: 14px;
letter-spacing: 0.3px;
}
#toast.visible {
opacity: 1;
transform: translateY(0);
}
body.text-hidden #vizRoot {
opacity: 0;
pointer-events: none;
transition: opacity 200ms ease;
}
canvas#viz {
position: fixed;
inset: 0;
width: 100vw;
height: 100vh;
display: block;
background: #000;
z-index: 1;
}
#ambientGlow {
position: fixed;
inset: 0;
background: radial-gradient(circle at 20% 20%, rgba(255, 99, 71, 0.12), transparent 45%),
radial-gradient(circle at 80% 70%, rgba(67, 143, 255, 0.15), transparent 50%);
filter: blur(60px);
z-index: 0;
}
@keyframes breathe {
0% { filter: drop-shadow(0 0 10px hsla(var(--accent-hue), 90%, 70%, 0.4)); }
50% { filter: drop-shadow(0 0 24px hsla(var(--accent-hue), 100%, 70%, 0.6)); }
100% { filter: drop-shadow(0 0 10px hsla(var(--accent-hue), 90%, 70%, 0.4)); }
}
@media (max-width: 900px) {
body { grid-template-columns: 1fr; padding: 18px; align-items: start; }
#vizRoot { order: 2; }
}
@media (max-width: 540px) {
#vizRoot { padding: 14px 12px; gap: 12px; }
#startBtn { font-size: 16px; padding: 12px 16px; width: 100%; }
[data-status] { font-size: 13px; }
}
</style>
<div id="ambientGlow"></div>
<canvas id="viz"></canvas>
<div id="toast" role="status" aria-live="polite"></div>

<div id="vizRoot">
<header>
<h1>Screen Audio Visualizer</h1>
<p>Share your screen with system audio to drive the visual chaos. The canvas fills the entire display while this panel keeps you informed.</p>
</header>

<div id="controls">
<button id="startBtn">▶ Share screen audio</button>
<div data-status data-tone="normal">Click start and choose <strong>Share system audio</strong> in the picker.</div>
</div>

<div id="helpers">
<div class="panel">
<h3>Fast start</h3>
<ol>
<li>Click the share button.</li>
<li>Pick the screen or tab you want.</li>
<li>Enable <strong>Share system audio</strong>.</li>
</ol>
</div>
<div class="panel">
<h3>Tips</h3>
<ul>
<li>Keep the share active; audio stops if the share ends.</li>
<li>Adjust your system volume for stronger visuals.</li>
<li>Change the source anytime—just click share again.</li>
</ul>
</div>
</div>
</div>

<div id="insanityControl" class="insanity-control hidden" aria-live="polite">
    <div>
        <div class="title">Insanity Boost</div>
        <div class="sub">Slide to tune the chaos</div>
    </div>
    <div class="slider-row">
        <input type="range" id="insanitySlider" min="0" max="140" value="70" step="1" aria-label="Insanity boost slider">
        <span id="insanityValue" class="value with-auto"><span id="insanityManualValue">70</span> <small id="insanityAutoValue" class="pill">auto</small></span>
    </div>
</div>

<script>
(function(){
const canvas = document.getElementById("viz");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("startBtn");
const statusEl = document.querySelector("[data-status]");
const toastEl = document.getElementById("toast");
const insanityControl = document.getElementById("insanityControl");
const insanitySlider = document.getElementById("insanitySlider");
const insanityValue = document.getElementById("insanityValue");
const insanityManualValue = document.getElementById("insanityManualValue");
const insanityAutoValue = document.getElementById("insanityAutoValue");
const videoKeepAlive = document.createElement("video");
videoKeepAlive.muted = true;
videoKeepAlive.playsInline = true;
videoKeepAlive.autoplay = true;
videoKeepAlive.style.position = "fixed";
videoKeepAlive.style.width = "1px";
videoKeepAlive.style.height = "1px";
videoKeepAlive.style.opacity = "0";
videoKeepAlive.setAttribute("aria-hidden", "true");
document.body.appendChild(videoKeepAlive);

let audioCtx, analyser, sourceNode, animationId, stream;
let pixelRatio = window.devicePixelRatio || 1;
const bars = 120;

// Color palette locked to deep neon tones (one hue per scene, concert-style swaps)
const palette = [320, 28, 212]; // magenta → flame orange → ultraviolet
const paletteHoldMs = 4200;
let paletteIndex = 0;
let targetHue = palette[paletteIndex];
let baseHue = targetHue;
let lastPaletteShift = 0;
const beatTimes = [];

// Tempo and drop detection helpers
let tempoFactor = 0.5;
let dropPulse = 0;
let bassMemory = 0;

let beatThreshold = 0.32;
let beatPulse = 0;
let flashPulse = 0;
let strobePulse = 0;
let lastBeat = 0;
const shockwaves = [];
let accentHue = 24;
let toastTimeout;
let insanityLevel = 70;
let autoInsanity = 0.65;
let insanityIntensity = 1;

function setStatus(msg, tone = "normal"){
if (statusEl){
statusEl.innerHTML = msg;
statusEl.dataset.tone = tone;
}
}

function showToast(message){
if (!toastEl) return;
toastEl.textContent = message;
toastEl.classList.add("visible");
if (toastTimeout) clearTimeout(toastTimeout);
toastTimeout = setTimeout(() => {
toastEl.classList.remove("visible");
}, 3000);
}

function hideText(){
document.body.classList.add("text-hidden");
}

function showText(){
document.body.classList.remove("text-hidden");
}

const clamp = (n, min, max) => Math.min(max, Math.max(min, n));

function softenManualInsanity(level){
const normalized = clamp(level / 140, 0, 1);
const gentleRamp = Math.min(normalized / 0.35, 1);
return normalized * (0.1 + 0.9 * gentleRamp * gentleRamp);
}

function updateInsanity(level){
insanityLevel = Number(level);
if (insanityManualValue){
insanityManualValue.textContent = insanityLevel;
}
if (insanityControl){
insanityControl.setAttribute("aria-label", `Insanity boost at ${insanityLevel}%. Use the slider to adjust the intensity.`);
}
if (insanitySlider && insanitySlider.value !== String(insanityLevel)){
insanitySlider.value = String(insanityLevel);
}
}
updateInsanity(insanityLevel);

function resize(){
pixelRatio = window.devicePixelRatio || 1;
canvas.width = window.innerWidth * pixelRatio;
canvas.height = window.innerHeight * pixelRatio;
ctx.setTransform(1, 0, 0, 1, 0, 0);
ctx.scale(pixelRatio, pixelRatio);
}
resize();
window.addEventListener("resize", resize);

function stopCurrentStream(){
if (stream){
stream.getTracks().forEach(t => t.stop());
stream = null;
}
if (sourceNode){
sourceNode.disconnect();
sourceNode = null;
}
if (analyser){
analyser.disconnect();
analyser = null;
}
if (animationId){
cancelAnimationFrame(animationId);
animationId = null;
}
showText();
insanityControl?.classList.remove("popped");
insanityControl?.classList.add("hidden");
if (videoKeepAlive){
try { videoKeepAlive.pause(); } catch (_) {}
videoKeepAlive.srcObject = null;
}
}

insanitySlider?.addEventListener("input", (evt) => {
updateInsanity((evt.target || {}).value || insanityLevel);
});

function draw(){
if (!analyser) return;
const freq = new Uint8Array(analyser.frequencyBinCount);
const time = new Uint8Array(analyser.fftSize);
analyser.getByteFrequencyData(freq);
analyser.getByteTimeDomainData(time);

const w = canvas.clientWidth;
const h = canvas.clientHeight;
ctx.save();

const bassBins = Math.max(4, Math.floor(freq.length * 0.16));
const midStart = bassBins;
const midBins = Math.max(6, Math.floor(freq.length * 0.28));

const bassEnergy = freq.slice(0, bassBins).reduce((a,b) => a + b, 0) / (bassBins * 255);
const midEnergy = freq.slice(midStart, midStart + midBins).reduce((a,b) => a + b, 0) / (midBins * 255);
const overallEnergy = freq.reduce((a,b) => a + b, 0) / (freq.length * 255);

const autoTarget = clamp(
0.32 + overallEnergy * 0.9 + tempoFactor * 0.55 + dropPulse * 0.8 + (bassEnergy - bassMemory) * 1.2,
0.18,
1.2
);
autoInsanity = autoInsanity * 0.9 + autoTarget * 0.1;
const manualInsanity = softenManualInsanity(insanityLevel);
const motionFactor = Math.pow(manualInsanity, 1.4);
const colorFactor = Math.pow(manualInsanity, 1.25);
const blendedInsanity = clamp(manualInsanity * 0.55 + autoInsanity * 0.65, 0.16, 1.2);
insanityIntensity = Math.max(0.14 + blendedInsanity * 0.7, Math.pow(blendedInsanity, 1.2));
const insanityChaos = Math.pow(blendedInsanity, 1.4);
const insanityBoost = insanityIntensity;
if (insanityAutoValue){
insanityAutoValue.textContent = `${Math.round(autoInsanity * 100)} auto`;
}

// Track sudden low-end surges for "beat drop" chaos
const bassDelta = bassEnergy - bassMemory;
bassMemory = bassMemory * 0.92 + bassEnergy * 0.08;
if (bassDelta > 0.18 && bassEnergy > bassMemory + 0.16){
dropPulse = 1;
}
dropPulse *= 0.9;

const now = performance.now();
// Gradually glide between fixed neon hues instead of rainbow spinning
const tempoHueSwing = tempoFactor * (18 * insanityBoost) * colorFactor;
const targetHueWithTempo = targetHue + Math.sin(now * 0.0006 * (1 + tempoFactor * 1.4) * (0.2 + colorFactor * 0.8)) * tempoHueSwing;
baseHue = baseHue * 0.9 + targetHueWithTempo * 0.1;
const accentSpread = (10 + overallEnergy * 12 * insanityBoost + bassEnergy * 18 * insanityBoost + tempoFactor * (14 * insanityBoost)) * (0.2 + colorFactor * 0.8);
accentHue = accentHue * 0.9 + (baseHue + Math.sin(now * 0.0015) * accentSpread) * 0.1;
document.documentElement.style.setProperty("--accent-hue", accentHue.toFixed(1));

if (bassEnergy > beatThreshold && now - lastBeat > 180){
beatPulse = 1;
flashPulse = 1;
strobePulse = 1;
shockwaves.push({ progress: 0 });
if (now - lastPaletteShift > paletteHoldMs){
paletteIndex = (paletteIndex + 1) % palette.length;
targetHue = palette[paletteIndex];
lastPaletteShift = now;
}

beatTimes.push(now);
if (beatTimes.length > 16) beatTimes.shift();
if (beatTimes.length >= 2){
const intervals = beatTimes.slice(1).map((t, i) => t - beatTimes[i]);
const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
const bpm = 60000 / Math.max(240, avgInterval);
const normalized = Math.min(1, Math.max(0, (bpm - 80) / 120));
tempoFactor = tempoFactor * 0.85 + normalized * 0.15;
}

beatThreshold = bassEnergy * 0.92;
lastBeat = now;
}
beatThreshold = Math.max(0.18, beatThreshold * 0.995 + bassEnergy * 0.005);
beatPulse *= 0.92;
flashPulse *= 0.9;
strobePulse *= 0.85;
const speedBoost = (0.9 + tempoFactor * 0.8 + dropPulse * 0.9) * insanityBoost * motionFactor;

ctx.clearRect(0, 0, w, h);

// Bass-driven zoom bursts & audio-driven camera shake
const shake = (Math.pow(bassEnergy, 1.2) * 55 + flashPulse * 18 + strobePulse * 22) * speedBoost * (0.5 + insanityBoost * 0.5) * (0.25 + motionFactor * 0.75);
const spin = (Math.random() - 0.5) * (bassEnergy + beatPulse * 0.4) * 0.22 * speedBoost * (0.4 + insanityBoost * 0.6) * (0.25 + motionFactor * 0.75);
const zoom = 1 + (bassEnergy * 0.2 + beatPulse * 0.16 + overallEnergy * 0.08) * speedBoost * (0.5 + insanityBoost * 0.5) * (0.25 + motionFactor * 0.75);
ctx.translate(w/2, h/2);
ctx.rotate(spin);
ctx.scale(zoom, zoom);
ctx.translate(-w/2 + (Math.random() - 0.5) * shake, -h/2 + (Math.random() - 0.5) * shake);

// Subtle psychedelic warp using sine-based skew on the camera
const warp = Math.sin(now * 0.002 * speedBoost) * (0.01 + overallEnergy * 0.02 + dropPulse * 0.03) * (0.6 + insanityBoost * 0.6) + beatPulse * 0.02 * speedBoost * (0.6 + insanityBoost * 0.4);
ctx.transform(1, warp, -warp, 1, 0, 0);

// Background gradient with saturation spikes
const saturationSpike = 60 + Math.min(40, (bassEnergy * 120 + midEnergy * 80 + tempoFactor * 50 + dropPulse * 60) * (0.4 + insanityBoost * 0.8));
const bg = ctx.createRadialGradient(w*0.35, h*0.35, h*0.05, w*0.5, h*0.5, h*0.8);
bg.addColorStop(0, `hsl(${baseHue % 360}, ${saturationSpike}%, ${18 + overallEnergy * 18}%)`);
bg.addColorStop(0.65, `hsl(${(baseHue + 12) % 360}, ${saturationSpike}%, ${8 + bassEnergy * 12}%)`);
bg.addColorStop(1, `hsl(${(baseHue + 24) % 360}, ${saturationSpike * 0.6}%, 4%)`);
ctx.fillStyle = bg;
ctx.fillRect(0, 0, w, h);

// Waveform ribbon
ctx.lineWidth = 2.5 * (0.6 + insanityBoost * 0.6);
ctx.strokeStyle = `hsla(${baseHue % 360}, 85%, 74%, ${0.5 + overallEnergy * 0.35 * insanityBoost})`;
ctx.beginPath();
for (let i = 0; i < time.length; i++){
const t = time[i] / 255;
const x = (i / (time.length - 1)) * w;
const y = h * 0.5 + (t - 0.5) * h * 0.35 * (0.4 + midEnergy * (0.8 + insanityChaos * 0.4));
if (i === 0) ctx.moveTo(x, y);
else ctx.lineTo(x, y);
}
ctx.stroke();

// Spectrum bars with strobe/flash color spikes
const barW = w / bars;
for (let i = 0; i < bars; i++){
const idx = Math.floor(i * (freq.length / bars));
const v = freq[idx] / 255;
const barH = Math.pow(v, 1.2 + insanityChaos * 0.4) * h * (0.6 + insanityBoost * 0.7);
const hue = baseHue % 360;
const sat = Math.min(100, 78 + saturationSpike * 0.28 + flashPulse * 35);
const light = 44 + v * 24 + flashPulse * 18;
ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
ctx.fillRect(i * barW, h - barH, barW - 1.5, barH);
}

// Neon particle shards
ctx.save();
ctx.globalCompositeOperation = "color-dodge";
ctx.lineWidth = 1.5 + overallEnergy * 3;
const shardCount = Math.floor((40 + tempoFactor * 20 + dropPulse * 30) * (0.6 + insanityBoost * 1.1));
for (let i = 0; i < shardCount; i++){
const t = (i / shardCount) * Math.PI * 2 + now * 0.002 * speedBoost + bassEnergy * 4;
const radius = (0.25 + Math.random() * 0.4 + midEnergy * 0.6 + dropPulse * 0.4) * Math.min(w, h) * (0.4 + insanityBoost * 0.8);
const px = w/2 + Math.cos(t) * radius;
const py = h/2 + Math.sin(t) * radius;
const len = 14 + Math.random() * 50 * (overallEnergy + 0.2 + dropPulse * 0.6) * (0.6 + insanityBoost * 1.2);
ctx.strokeStyle = `hsla(${accentHue % 360}, 100%, ${60 + midEnergy * 30}%, ${0.35 + overallEnergy * 0.4 * insanityBoost})`;
ctx.beginPath();
ctx.moveTo(px, py);
ctx.lineTo(px + Math.cos(t) * len, py + Math.sin(t) * len);
ctx.stroke();
}
ctx.restore();

// Glitch / distortion slices on stronger hits
if (Math.random() < (0.12 + bassEnergy * 0.25 + beatPulse * 0.45 + dropPulse * 0.4) * (0.4 + insanityBoost * 1)){
const slices = 2 + Math.floor(Math.random() * 3 * (0.8 + insanityBoost));
for (let i = 0; i < slices; i++){
const sliceH = h * (0.03 + Math.random() * 0.1 + dropPulse * 0.12) * (0.6 + insanityBoost * 1.1);
const y = Math.random() * (h - sliceH);
const drift = (Math.random() - 0.5) * (30 + bassEnergy * 120 + beatPulse * 180 + dropPulse * 260) * (0.5 + insanityBoost * 0.9);
ctx.globalCompositeOperation = "lighter";
ctx.drawImage(canvas, 0, y, w, sliceH, drift, y, w, sliceH);
}
ctx.globalCompositeOperation = "source-over";
}

// Shockwave pulse (screen expands/warps outward on kicks)
for (let i = shockwaves.length - 1; i >= 0; i--){
const sw = shockwaves[i];
sw.progress += (0.025 + bassEnergy * 0.09 + tempoFactor * 0.03 + dropPulse * 0.05) * (0.7 + insanityBoost * 0.8);
const radius = Math.min(w, h) * sw.progress * (1.4 + insanityBoost * 0.6);
const g = ctx.createRadialGradient(w/2, h/2, radius * 0.25, w/2, h/2, radius);
g.addColorStop(0, `hsla(${baseHue % 360}, 95%, 80%, ${0.4 - sw.progress * 0.3})`);
g.addColorStop(1, "rgba(255,255,255,0)");
ctx.globalCompositeOperation = "screen";
ctx.beginPath();
ctx.fillStyle = g;
ctx.arc(w/2, h/2, radius, 0, Math.PI * 2);
ctx.fill();
ctx.globalCompositeOperation = "source-over";
if (sw.progress >= 1) shockwaves.splice(i, 1);
}

// Bloom flashes & beat synced flashing
if (flashPulse > 0.01){
ctx.fillStyle = `rgba(255,255,255,${(0.32 * flashPulse + overallEnergy * 0.08) * (0.6 + insanityBoost * 0.8)})`;
ctx.fillRect(0, 0, w, h);
}

// Audio-Reactive strobing & vignette flicker
const strobeAlpha = Math.max(strobePulse * 0.9, Math.sin(now * 0.02 * speedBoost) * (overallEnergy * 1.4 + dropPulse * 0.8) * (0.6 + insanityBoost * 0.9));
if (strobeAlpha > 0.02){
const hueFlash = baseHue % 360;
ctx.fillStyle = `hsla(${hueFlash}, 95%, 75%, ${(strobeAlpha * 0.55 + flashPulse * 0.45) * (0.6 + insanityBoost * 0.7)})`;
ctx.fillRect(0, 0, w, h);
}

const vignette = ctx.createRadialGradient(w/2, h/2, h*0.1, w/2, h/2, h*0.75);
vignette.addColorStop(0, "rgba(0,0,0,0)");
vignette.addColorStop(1, `rgba(0,0,0,${(0.35 + midEnergy * 0.45 + Math.random() * 0.08 * midEnergy) * (0.6 + insanityBoost * 0.7)})`);
ctx.fillStyle = vignette;
ctx.fillRect(0, 0, w, h);

// Bass-driven zoom bursts highlight
if (bassEnergy > 0.12){
ctx.fillStyle = `rgba(255, 255, 255, ${(bassEnergy * 0.12 + beatPulse * 0.18 + dropPulse * 0.2) * (0.6 + insanityBoost * 0.8)})`;
ctx.fillRect(0, 0, w, h);
}

// Extra bloom when a drop hits
if (dropPulse > 0.08){
ctx.globalCompositeOperation = "screen";
ctx.fillStyle = `hsla(${(baseHue + 180) % 360}, 100%, 70%, ${(dropPulse * 0.4) * (0.6 + insanityBoost * 1.2)})`;
ctx.fillRect(0, 0, w, h);
ctx.globalCompositeOperation = "source-over";
}

ctx.restore();
animationId = requestAnimationFrame(draw);
}

if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia){
setStatus("Your browser does not support screen capture. Please update and try again.");
startBtn.disabled = true;
return;
}

startBtn.addEventListener("click", async () => {
setStatus("Requesting screen share with audio. Make sure to enable system audio in the picker.");
startBtn.disabled = true;

try {
stopCurrentStream();

const capture = await navigator.mediaDevices.getDisplayMedia({
video: { displaySurface: "monitor" },
audio: {
echoCancellation: false,
noiseSuppression: false,
suppressLocalAudioPlayback: false
}
});

const audioTracks = capture.getAudioTracks();
if (!audioTracks.length){
setStatus("Audio wasn't included. Restart sharing and choose <strong>Share system audio</strong> so the visuals can react.", "warn");
startBtn.disabled = false;
capture.getTracks().forEach(t => t.stop());
return;
}

stream = capture;
videoKeepAlive.srcObject = capture;
videoKeepAlive.play().catch(() => {});

audioCtx = audioCtx || new AudioContext();
await audioCtx.resume();

analyser = audioCtx.createAnalyser();
analyser.fftSize = 512;
analyser.smoothingTimeConstant = 0.7;

sourceNode = audioCtx.createMediaStreamSource(stream);
sourceNode.connect(analyser);

setStatus("Listening to your screen audio. Keep screen audio shared for full-reactive chaos.");
hideText();
showToast("Audio successfully connected");
insanityControl?.classList.remove("hidden");
requestAnimationFrame(() => insanityControl?.classList.add("popped"));
draw();

audioTracks[0].addEventListener("ended", () => {
stopCurrentStream();
setStatus("Screen share ended. Click the button and share system audio to relaunch the visualizer.", "warn");
startBtn.disabled = false;
});

capture.getVideoTracks()[0]?.addEventListener("ended", () => {
stopCurrentStream();
setStatus("Screen share ended. Click the button and share system audio to relaunch the visualizer.", "warn");
startBtn.disabled = false;
});
} catch (err) {
console.error(err);
setStatus("Screen share didn't start. Please allow access and try again with <strong>Share system audio</strong> enabled.", "warn");
startBtn.disabled = false;
}
});
})();
</script>