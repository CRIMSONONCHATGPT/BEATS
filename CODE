  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Screen Audio Visualizer</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at 30% 30%, #0a0f1e 0%, #050910 40%, #02040a 70%);
      color: #e8edf3;
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
    }
    body {
      display: grid;
      place-items: center;
    }
    #vizRoot {
      position: fixed;
      inset: 50% auto auto 50%;
      transform: translate(-50%, -50%);
      width: min(640px, calc(100vw - 32px));
      box-sizing: border-box;
      text-align: center;
      z-index: 5;
      padding: 12px 18px;
      background: rgba(8, 12, 22, 0.65);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 14px;
      box-shadow: 0 0 28px rgba(0, 0, 0, 0.45);
      backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 10px;
      backdrop-filter: blur(18px) saturate(180%);
      box-shadow:
        0 0 28px rgba(0, 0, 0, 0.45),
        0 0 60px rgba(255, 99, 71, 0.18),
        0 0 120px rgba(70, 165, 255, 0.12);
    }
    #startWrap {
      width: 100%;
    }
    #startBtn {
      display: block;
      width: 100%;
      max-width: 100%;
      padding: 14px 20px;
      font-size: 18px;
      border: 0;
      border-radius: 10px;
      background: linear-gradient(120deg, hsl(var(--accent-hue, 15), 90%, 62%), hsl(calc(var(--accent-hue, 15) + 70), 85%, 58%));
      color: #fff;
      cursor: pointer;
      box-shadow:
        0 0 18px hsla(var(--accent-hue, 15), 95%, 60%, 0.55),
        0 0 36px hsla(calc(var(--accent-hue, 15) + 120), 95%, 70%, 0.28);
      transition: transform 160ms ease, box-shadow 160ms ease, filter 120ms ease;
      animation: breathe 2.2s ease-in-out infinite;
    }
    #startBtn:hover {
      transform: translateY(-2px) scale(1.01);
      box-shadow: 0 10px 28px rgba(255, 64, 64, 0.55);
    }
    #startBtn:focus-visible {
      outline: 2px solid rgba(255, 255, 255, 0.45);
      outline-offset: 2px;
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.12);
    }
    #startBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    [data-status] {
      margin-top: 10px;
      font-size: 14px;
      color: #cdd9e5;
    }
    canvas#viz {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      background: #000;
    }
    @keyframes breathe {
      0% { filter: drop-shadow(0 0 10px hsla(var(--accent-hue, 15), 90%, 70%, 0.4)); }
      50% { filter: drop-shadow(0 0 24px hsla(calc(var(--accent-hue, 15) + 60), 100%, 70%, 0.65)); }
      100% { filter: drop-shadow(0 0 10px hsla(var(--accent-hue, 15), 90%, 70%, 0.4)); }
    }
    @media (max-width: 540px) {
      #vizRoot {
        top: 50%;
        padding: 10px 12px;
      }
      #startBtn {
        font-size: 16px;
        padding: 12px 16px;
      }
      [data-status] {
        font-size: 13px;
      }
    }
  </style>
  <div id="vizRoot">
    <div id="startWrap">
      <button id="startBtn">▶ Share screen audio</button>
    </div>
    <div data-status>Click start and choose <strong>Share system audio</strong> so the visualizer can react.</div>
  </div>

  <canvas id="viz"></canvas>

  <script>
  (function(){
    const canvas = document.getElementById("viz");
    const ctx = canvas.getContext("2d");
    const startBtn = document.getElementById("startBtn");
    const startWrap = document.getElementById("startWrap");
    const statusEl = document.querySelector("[data-status]");

    let audioCtx, analyser, sourceNode, animationId, stream;
    let pixelRatio = window.devicePixelRatio || 1;
    const bars = 120;

    // Color palette locked to deep neon tones (no rainbow spinning)
    const palette = [0, 300, 140]; // red → purple → green
    let paletteIndex = 0;
    let targetHue = palette[paletteIndex];
    let baseHue = targetHue;

    let beatThreshold = 0.32;
    let beatPulse = 0;
    let flashPulse = 0;
    let strobePulse = 0;
    let lastBeat = 0;
    const shockwaves = [];
    let accentHue = 24;

    function setStatus(msg){
      if (statusEl) statusEl.innerHTML = msg;
    }

    function resize(){
      pixelRatio = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * pixelRatio;
      canvas.height = window.innerHeight * pixelRatio;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(pixelRatio, pixelRatio);
    }
    resize();
    window.addEventListener("resize", resize);

    function stopCurrentStream(){
      if (stream){
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      if (sourceNode){
        sourceNode.disconnect();
        sourceNode = null;
      }
      if (analyser){
        analyser.disconnect();
        analyser = null;
      }
      if (animationId){
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    }

    function draw(){
      if (!analyser) return;
      const freq = new Uint8Array(analyser.frequencyBinCount);
      const time = new Uint8Array(analyser.fftSize);
      analyser.getByteFrequencyData(freq);
      analyser.getByteTimeDomainData(time);

      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.save();

      const bassBins = Math.max(4, Math.floor(freq.length * 0.16));
      const midStart = bassBins;
      const midBins = Math.max(6, Math.floor(freq.length * 0.28));

      const bassEnergy = freq.slice(0, bassBins).reduce((a,b) => a + b, 0) / (bassBins * 255);
      const midEnergy = freq.slice(midStart, midStart + midBins).reduce((a,b) => a + b, 0) / (midBins * 255);
      const overallEnergy = freq.reduce((a,b) => a + b, 0) / (freq.length * 255);

      // Gradually glide between fixed neon hues (red → purple → green) instead of rainbow spinning
      baseHue = baseHue * 0.9 + targetHue * 0.1;
      accentHue = accentHue * 0.85 + (baseHue + overallEnergy * 25 + bassEnergy * 45) * 0.15;
      document.documentElement.style.setProperty("--accent-hue", accentHue.toFixed(1));

      const now = performance.now();
      if (bassEnergy > beatThreshold && now - lastBeat > 180){
        beatPulse = 1;
        flashPulse = 1;
        strobePulse = 1;
        shockwaves.push({ progress: 0 });
        paletteIndex = (paletteIndex + 1) % palette.length;
        targetHue = palette[paletteIndex];
        beatThreshold = bassEnergy * 0.92;
        lastBeat = now;
      }
      beatThreshold = Math.max(0.18, beatThreshold * 0.995 + bassEnergy * 0.005);
      beatPulse *= 0.92;
      flashPulse *= 0.9;
      strobePulse *= 0.85;

      ctx.clearRect(0, 0, w, h);

      // Bass-driven zoom bursts & audio-driven camera shake
      const shake = Math.pow(bassEnergy, 1.2) * 55 + flashPulse * 18 + strobePulse * 22;
      const spin = (Math.random() - 0.5) * (bassEnergy + beatPulse * 0.4) * 0.22;
      const zoom = 1 + bassEnergy * 0.2 + beatPulse * 0.16 + overallEnergy * 0.08;
      ctx.translate(w/2, h/2);
      ctx.rotate(spin);
      ctx.scale(zoom, zoom);
      ctx.translate(-w/2 + (Math.random() - 0.5) * shake, -h/2 + (Math.random() - 0.5) * shake);

      // Subtle psychedelic warp using sine-based skew on the camera
      const warp = Math.sin(now * 0.002) * (0.01 + overallEnergy * 0.02) + beatPulse * 0.02;
      ctx.transform(1, warp, -warp, 1, 0, 0);

      // Background gradient with saturation spikes
      const saturationSpike = 60 + Math.min(40, bassEnergy * 120 + midEnergy * 80);
      const bg = ctx.createRadialGradient(w*0.35, h*0.35, h*0.05, w*0.5, h*0.5, h*0.8);
      bg.addColorStop(0, `hsl(${(baseHue + 20) % 360}, ${saturationSpike}%, ${18 + overallEnergy * 18}%)`);
      bg.addColorStop(0.6, `hsl(${(baseHue + 80) % 360}, ${saturationSpike}%, ${8 + bassEnergy * 12}%)`);
      bg.addColorStop(1, `hsl(${(baseHue + 160) % 360}, ${saturationSpike * 0.6}%, 4%)`);
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, w, h);

      // Waveform ribbon
      ctx.lineWidth = 2.5;
      ctx.strokeStyle = `hsla(${(baseHue + 60) % 360}, 85%, 75%, ${0.5 + overallEnergy * 0.35})`;
      ctx.beginPath();
      for (let i = 0; i < time.length; i++){
        const t = time[i] / 255;
        const x = (i / (time.length - 1)) * w;
        const y = h * 0.5 + (t - 0.5) * h * 0.35 * (0.6 + midEnergy * 0.8);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Spectrum bars with strobe/flash color spikes
      const barW = w / bars;
      for (let i = 0; i < bars; i++){
        const idx = Math.floor(i * (freq.length / bars));
        const v = freq[idx] / 255;
        const barH = Math.pow(v, 1.2) * h;
        const hue = (baseHue + (i / bars) * 40 + flashPulse * 60) % 360;
        const sat = Math.min(100, 72 + saturationSpike * 0.35 + flashPulse * 35);
        const light = 42 + v * 26 + flashPulse * 22;
        ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
        ctx.fillRect(i * barW, h - barH, barW - 1.5, barH);
      }

      // Neon particle shards
      ctx.save();
      ctx.globalCompositeOperation = "color-dodge";
      ctx.lineWidth = 1.5 + overallEnergy * 3;
      for (let i = 0; i < 40; i++){
        const t = (i / 40) * Math.PI * 2 + now * 0.002 + bassEnergy * 4;
        const radius = (0.25 + Math.random() * 0.4 + midEnergy * 0.6) * Math.min(w, h) * 0.5;
        const px = w/2 + Math.cos(t) * radius;
        const py = h/2 + Math.sin(t) * radius;
        const len = 14 + Math.random() * 50 * (overallEnergy + 0.2);
        ctx.strokeStyle = `hsla(${(accentHue + i * 4) % 360}, 100%, ${60 + midEnergy * 30}%, ${0.35 + overallEnergy * 0.4})`;
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px + Math.cos(t) * len, py + Math.sin(t) * len);
        ctx.stroke();
      }
      ctx.restore();

      // Glitch / distortion slices on stronger hits
      if (Math.random() < 0.12 + bassEnergy * 0.25 + beatPulse * 0.45){
        const slices = 2 + Math.floor(Math.random() * 3);
        for (let i = 0; i < slices; i++){
          const sliceH = h * (0.03 + Math.random() * 0.1);
          const y = Math.random() * (h - sliceH);
          const drift = (Math.random() - 0.5) * (30 + bassEnergy * 120 + beatPulse * 180);
          ctx.globalCompositeOperation = "lighter";
          ctx.drawImage(canvas, 0, y, w, sliceH, drift, y, w, sliceH);
        }
        ctx.globalCompositeOperation = "source-over";
      }

      // Shockwave pulse (screen expands/warps outward on kicks)
      for (let i = shockwaves.length - 1; i >= 0; i--){
        const sw = shockwaves[i];
        sw.progress += 0.025 + bassEnergy * 0.09;
        const radius = Math.min(w, h) * sw.progress * 1.4;
        const g = ctx.createRadialGradient(w/2, h/2, radius * 0.25, w/2, h/2, radius);
        g.addColorStop(0, `hsla(${(baseHue + 30) % 360}, 95%, 80%, ${0.4 - sw.progress * 0.3})`);
        g.addColorStop(1, "rgba(255,255,255,0)");
        ctx.globalCompositeOperation = "screen";
        ctx.beginPath();
        ctx.fillStyle = g;
        ctx.arc(w/2, h/2, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = "source-over";
        if (sw.progress >= 1) shockwaves.splice(i, 1);
      }

      // Bloom flashes & beat synced flashing
      if (flashPulse > 0.01){
        ctx.fillStyle = `rgba(255,255,255,${0.32 * flashPulse + overallEnergy * 0.08})`;
        ctx.fillRect(0, 0, w, h);
      }

      // Audio-Reactive strobing & vignette flicker
      const strobeAlpha = Math.max(strobePulse * 0.9, Math.sin(now * 0.02) * (overallEnergy * 1.4));
      if (strobeAlpha > 0.02){
        const hueFlash = (baseHue + 30) % 360;
        ctx.fillStyle = `hsla(${hueFlash}, 95%, 75%, ${strobeAlpha * 0.55 + flashPulse * 0.45})`;
        ctx.fillRect(0, 0, w, h);
      }

      const vignette = ctx.createRadialGradient(w/2, h/2, h*0.1, w/2, h/2, h*0.75);
      vignette.addColorStop(0, "rgba(0,0,0,0)");
      vignette.addColorStop(1, `rgba(0,0,0,${0.35 + midEnergy * 0.45 + Math.random() * 0.08 * midEnergy})`);
      ctx.fillStyle = vignette;
      ctx.fillRect(0, 0, w, h);

      // Bass-driven zoom bursts highlight
      if (bassEnergy > 0.12){
        ctx.fillStyle = `rgba(255, 255, 255, ${bassEnergy * 0.12 + beatPulse * 0.18})`;
        ctx.fillRect(0, 0, w, h);
      }

      ctx.restore();
      animationId = requestAnimationFrame(draw);
    }

    if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia){
      setStatus("Your browser does not support screen capture. Please update and try again.");
      startBtn.disabled = true;
      return;
    }

    startBtn.addEventListener("click", async () => {
      setStatus("Requesting screen share with audio. Make sure to enable system audio in the picker.");
      startWrap.style.display = "none";

      try {
        stopCurrentStream();

        const capture = await navigator.mediaDevices.getDisplayMedia({
          video: { displaySurface: "monitor" },
          audio: {
            echoCancellation: false,
            noiseSuppression: false,
            suppressLocalAudioPlayback: false
          }
        });

        const audioTracks = capture.getAudioTracks();
        if (!audioTracks.length){
          setStatus("No audio was shared. Please enable audio when sharing your screen.");
          startWrap.style.display = "block";
          capture.getTracks().forEach(t => t.stop());
          return;
        }

        capture.getVideoTracks().forEach(t => t.stop());
        stream = capture;

        audioCtx = audioCtx || new AudioContext();
        await audioCtx.resume();

        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 512;
        analyser.smoothingTimeConstant = 0.7;

        sourceNode = audioCtx.createMediaStreamSource(stream);
        sourceNode.connect(analyser);

        setStatus("Listening to your screen audio. Keep screen audio shared for full-reactive chaos.");
        draw();

        audioTracks[0].addEventListener("ended", () => {
          stopCurrentStream();
          setStatus("Screen share ended. Click the button and share system audio to relaunch the visualizer.");
          startWrap.style.display = "block";
        });
      } catch (err) {
        console.error(err);
        setStatus("Screen share was blocked or failed. Please allow access and try again with audio enabled.");
        startWrap.style.display = "block";
      }
    });
  })();
  </script>
